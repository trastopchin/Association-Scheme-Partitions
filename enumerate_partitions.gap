# Tal Rastopchin and Gabby Masini
# April 7, 2020

# Read("enumerate_partitions.gap");

# load Miyamoto and Hanaki's elementary functions for association schemes
Read("./association_scheme.gap");

# load Miyamoto and Hanaki's classified association schemes of order 5 and 16
# as05 is a list of the schemes of order 5
Read("./classified_schemes/schemes_order05.gap");
Read("./classified_schemes/schemes_order06.gap");
Read("./classified_schemes/schemes_order07.gap");
Read("./classified_schemes/schemes_order08.gap");
Read("./classified_schemes/schemes_order09.gap");
Read("./classified_schemes/schemes_order10.gap");

# prints a new line
Newline := function()
	Print("\n");
end;

# prints an object with a new line
Println := function(object)
	Print(object);
  Print("\n");
end;

# prints out a matrix with better formatting
PrintMatrix := function(A)
	local row;
	for row in A do
		Println(row);
	od;
	Print("\n");
end;

# makes a zero vector of dimension n
MyZeroVector := function (n)
  local zeroVector, i;
  zeroVector := [];
  # is there a faster way of doing this?
  for i in [1..n] do
    Add(zeroVector, 0);
  od;
  return zeroVector;
end;

# enumerates our partition bases
EnumeratePartitionBases := function (n)
  local partitionBases, partitions, partition, partitionBasis, part, partitionVector, element;

  partitionBases := []; # the set of partition bases
  partitions := PartitionsSet([1..n]); # compute partitions

  # each partition gives us a partition basis
  for partition in partitions do
    partitionBasis := []; # the current set of j vectors

    for part in partition do
      partitionVector := MyZeroVector(n); # the current j vector

      for element in part do
        partitionVector[element] := 1;
      od;

      Add(partitionBasis, partitionVector);
    od;
    Add(partitionBases, partitionBasis);
  od;

  # Println(partitions);
  # Newline();
  # Println(partitionBases);

  return partitionBases;
end;

# https://en.wikipedia.org/wiki/Free_module

# i claim that given sigma_p and j_i, there exist k nonnegative integers b_pi^l
# such that (sigma_p * j_i) = (sum from l = 1 to k)(b_pi^l j_i)
# if and only if (sigma_p * j_i) is in the span of the basis of the module over
# the integers generated by set of j vectors {j_1, j_2, ..., j_k}

ComputeGoodPartitions := function(schemes, order)
	local schemeIndex, numGoodPartitions, partitionBases, R, partitionBasis, basis, isGoodPartition, j, sigma, result;

	# enumerate potential partition bases
	partitionBases := EnumeratePartitionBases(order);

	schemeIndex := 0;
	# for each scheme
	for R in schemes do
		schemeIndex := schemeIndex + 1;
		numGoodPartitions := 0;

		# for each potential partition basis
		for partitionBasis in partitionBases do

			# create a module from our basis over Z
			basis := MutableBasis(Integers, partitionBasis);

			# check if all numbers b_pi^l exist
			isGoodPartition := true;
			for j in partitionBasis do
				for sigma in AdjacencyMatrices(R) do
					result := sigma * j; # sigma_p * j_i
					# no such  b_pi^l exists -> not a good partition
					if not(IsContainedInSpan(basis, result)) then
						isGoodPartition := false;
					fi;
				od;
			od;

			# if a good partition
			if isGoodPartition = true then
				numGoodPartitions := numGoodPartitions + 1;
				#Println("The partition basis ");
				#PrintMatrix(TransposedMat(partitionBasis));
				#Println("Is a good partitioning of ");
				#PrintMatrix(R);
			fi;
		od;
		Print("Scheme ");
		Print(schemeIndex);
		Print(" has ");
		Print(numGoodPartitions);
		Println(" good partitions.");
	od;
	return numGoodPartitions;
end;

Println("Computing good partitions on schemes of order 8:");
ComputeGoodPartitions(as08, 8);
